<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Exploratory Data Analysis (EDA)</title>
    <meta charset="utf-8" />
    <meta name="author" content="MACSS 30500   University of Chicago" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link href="index_files/panelset/panelset.css" rel="stylesheet" />
    <script src="index_files/panelset/panelset.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Exploratory Data Analysis (EDA)
]
.author[
### MACSS 30500 <br /> University of Chicago
]

---






class: inverse, middle

# Exploratory Data Analysis (EDA)

---

### EDA Definition

All set of **INITIAL** investigations to understand your data and generate questions, before running more complex analyses (e.g., modeling). 

Goals: 

+ discover patterns 
+ spot anomalies (outliers)
+ generate questions 
+ check initial hypotheses before formally testing them

**Exploratory Data Analysis or EDA** is different from **Explanatory or Confirmatory Data Analysis**

---

### EDA is an iterative and creative process

Our book, "R for Data Science," defines EDA as an **ITERATIVE process**:

1. Generate exploratory questions about your data
1. Search for answers in the data
1. Use what you learn to refine your questions and/or generate new questions
1. Repeat until necessary

--

&lt;br&gt;

EDA is a also a **CREATIVE process**: it is not an exact science, and requires intuition and patience. At the most basic level, it involves answering two questions:

* What type of variation occurs within my variable(s)?
* What type of covariation occurs between my variables?


---

### EDA relies on visualizations and descriptive stats

**Visualizations** such histograms, bar charts, scatter plots, etc. 

**Descriptive stats** such as measures of central tendency (mean, mode, median) and dispersion (variance, standard deviation)

--

&lt;br&gt;

**We focus on visualizations and especially on:**
- Variation: how values within a single variable vary (univariate analysis)
- Covariation: how values of two variables co-vary (bivariate analysis)

--

*Visualizations are employed in both Exploratory and Confirmatory Data Analysis, but their use is different. Let's see an example with the penguins data...* 

&lt;!--
In Exploratory Analysis you might generate 10, 20 or even 100 graphs, but not all of them will be useful for your research. In Confirmatory Analysis, you generate only a few graphs and each graph is well refined and will be put in your final report or research.
--&gt;

---

class: inverse, middle

# Exploratory VS. Confirmatory Data Analysis

---

## Comparing Exploratory VS. Confirmatory plots


```r
library(palmerpenguins)
data("penguins")

head(penguins)
```

```
## # A tibble: 6 x 8
##   species island    bill_length_mm bill_depth_mm flipper_l~1 body_~2 sex    year
##   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;       &lt;int&gt;   &lt;int&gt; &lt;fct&gt; &lt;int&gt;
## 1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007
## 2 Adelie  Torgersen           39.5          17.4         186    3800 fema~  2007
## 3 Adelie  Torgersen           40.3          18           195    3250 fema~  2007
## 4 Adelie  Torgersen           NA            NA            NA      NA &lt;NA&gt;   2007
## 5 Adelie  Torgersen           36.7          19.3         193    3450 fema~  2007
## 6 Adelie  Torgersen           39.3          20.6         190    3650 male   2007
## # ... with abbreviated variable names 1: flipper_length_mm, 2: body_mass_g
```

We want build a plot of two continuous variables: penguins body mass and flipper length.

&lt;!-- Let's build this plot step by step --&gt;

---



count: false
 
## Exploratory plot
.panel1-penguins-eda-auto[

```r
*ggplot(
* data = penguins,
* mapping = aes(
*   x = body_mass_g,
*   y = flipper_length_mm)
* )
```
]
 
.panel2-penguins-eda-auto[
&lt;img src="index_files/figure-html/penguins-eda_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Exploratory plot
.panel1-penguins-eda-auto[

```r
ggplot(
  data = penguins,
  mapping = aes(
    x = body_mass_g,
    y = flipper_length_mm)
  ) +
* geom_point()
```
]
 
.panel2-penguins-eda-auto[
&lt;img src="index_files/figure-html/penguins-eda_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Exploratory plot
.panel1-penguins-eda-auto[

```r
ggplot(
  data = penguins,
  mapping = aes(
    x = body_mass_g,
    y = flipper_length_mm)
  ) +
  geom_point() +
* geom_smooth()
```
]
 
.panel2-penguins-eda-auto[
&lt;img src="index_files/figure-html/penguins-eda_auto_03_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-penguins-eda-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-penguins-eda-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-penguins-eda-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



&lt;!-- notice in the code I put the data and mapping above, right after ggplot() because both geometries use the same data and mapping --&gt;

--

Exploratory plot: What does this graph tell us? Pros and cons? And how can we improve it?

&lt;!--
Pros: minimum code, easy to replicate, good for your internal use
Cons: not well refined, not good for publication or external audience
--&gt;

---



count: false
 
## Confirmatory plot
.panel1-penguins-final-auto[

```r
*ggplot(
* data = penguins,
* mapping = aes(
*   x = body_mass_g,
*   y = flipper_length_mm)
* )
```
]
 
.panel2-penguins-final-auto[
&lt;img src="index_files/figure-html/penguins-final_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Confirmatory plot
.panel1-penguins-final-auto[

```r
ggplot(
  data = penguins,
  mapping = aes(
    x = body_mass_g,
    y = flipper_length_mm)
  ) +
* geom_point(alpha = .1)
```
]
 
.panel2-penguins-final-auto[
&lt;img src="index_files/figure-html/penguins-final_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Confirmatory plot
.panel1-penguins-final-auto[

```r
ggplot(
  data = penguins,
  mapping = aes(
    x = body_mass_g,
    y = flipper_length_mm)
  ) +
  geom_point(alpha = .1) +
* geom_smooth(method = "lm",
*             se = FALSE)
```
]
 
.panel2-penguins-final-auto[
&lt;img src="index_files/figure-html/penguins-final_auto_03_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Confirmatory plot
.panel1-penguins-final-auto[

```r
ggplot(
  data = penguins,
  mapping = aes(
    x = body_mass_g,
    y = flipper_length_mm)
  ) +
  geom_point(alpha = .1) +
  geom_smooth(method = "lm",
              se = FALSE) +
* labs(
*   title = "Relationship between body mass and\nflipper length of a penguin",
*   subtitle = "Sample of 344 penguins",
*   x = "Body mass (g)",
*   y = "Flipper length (mm)"
* )
```
]
 
.panel2-penguins-final-auto[
&lt;img src="index_files/figure-html/penguins-final_auto_04_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Confirmatory plot
.panel1-penguins-final-auto[

```r
ggplot(
  data = penguins,
  mapping = aes(
    x = body_mass_g,
    y = flipper_length_mm)
  ) +
  geom_point(alpha = .1) +
  geom_smooth(method = "lm",
              se = FALSE) +
  labs(
    title = "Relationship between body mass and\nflipper length of a penguin",
    subtitle = "Sample of 344 penguins",
    x = "Body mass (g)",
    y = "Flipper length (mm)"
  ) +
* theme_xaringan(
*   title_font_size = 18,
*   text_font_size = 16
* )
```
]
 
.panel2-penguins-final-auto[
&lt;img src="index_files/figure-html/penguins-final_auto_05_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-penguins-final-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-penguins-final-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-penguins-final-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



&lt;!-- notice here geom_point and geom_smooth also have their own arguments that work only for them; 
for example:
if I want to make the points of the scatterplot more faded I use alpha there; 
or here I wanted to use a specific method to draw the regression line vs. let R selecting it automatically, so I specify the method and I also do se = FALSE as the default is true and shows the standard error

labs() and theme_xarigan() control the non-data elements of the plot; lab(): controls things like title, subtitles etc; theme() controls background colors, font size, etc.

Notice there is also a geometry that controls titles etc. and it is called geom_text()
Note the difference between `labs()` and `geom_text()` 
Book "`ggplot2`: Elegant Graphics for Data Analysis" https://ggplot2-book.org/annotations.html

--&gt;



---

### Bottom line...

**The initial plot was created for exploratory purposes**. We might generate several plots similar to this plot to explore the data. 

**The last plot was created for confirmatory purposes**. We begin with an exploratory plot and refine it with more code. Use it for a final report, class presentation, paper, final submission of HW2 for this course, etc.

---

class: inverse, middle

# EDA with the `scorecard` dataset

The Department of Education collects annual statistics on colleges and universities in the United States. We are going to look at a subset of this data, from 2018-19.

---

## `scorecard`


```r
library(tidyverse)
library(rcis)
data("scorecard")
glimpse(scorecard)
```

```
## Rows: 1,732
## Columns: 14
## $ unitid    &lt;dbl&gt; 100654, 100663, 100706, 100724, 100751, 100830, 100858, 1009~
## $ name      &lt;chr&gt; "Alabama A &amp; M University", "University of Alabama at Birmin~
## $ state     &lt;chr&gt; "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", ~
## $ type      &lt;fct&gt; "Public", "Public", "Public", "Public", "Public", "Public", ~
## $ admrate   &lt;dbl&gt; 0.9175, 0.7366, 0.8257, 0.9690, 0.8268, 0.9044, 0.8067, 0.53~
## $ satavg    &lt;dbl&gt; 939, 1234, 1319, 946, 1261, 1082, 1300, 1230, 1066, NA, 1076~
## $ cost      &lt;dbl&gt; 23053, 24495, 23917, 21866, 29872, 19849, 31590, 32095, 3431~
## $ netcost   &lt;dbl&gt; 14990, 16953, 15860, 13650, 22597, 13987, 24104, 22107, 2071~
## $ avgfacsal &lt;dbl&gt; 69381, 99441, 87192, 64989, 92619, 71343, 96642, 56646, 5400~
## $ pctpell   &lt;dbl&gt; 0.7019, 0.3512, 0.2536, 0.7627, 0.1772, 0.4644, 0.1455, 0.23~
## $ comprate  &lt;dbl&gt; 0.2974, 0.6340, 0.5768, 0.3276, 0.7110, 0.3401, 0.7911, 0.69~
## $ firstgen  &lt;dbl&gt; 0.3658281, 0.3412237, 0.3101322, 0.3434343, 0.2257127, 0.381~
## $ debt      &lt;dbl&gt; 15250, 15085, 14000, 17500, 17671, 12000, 17500, 16000, 1425~
## $ locale    &lt;fct&gt; City, City, City, City, City, City, City, City, City, Suburb~
```

---

## Types of visualizations we can perform

#### VARIATION or how values within a single variable vary (univariate analysis)
  
* one continuous variable: **histogram plot**
* one categorical variable: **bar plot**

#### COVARIATION or how values of two variables co-vary (bivariate analysis)

* two continuous variables: **scatter plot**
* two categorical variables: **bar plot**; pie chart; dot plot; mosaic plot
* one categorical and one continuous variables: **box plot**; **scatter plot with colors** (one color for each category of the categorical variables); **faceted histogram** (one histogram for each category of the categorical variable)

--

*Takeaway from today's lecture: match the type of plot with the variable types!*

&lt;!-- in bold all plots we see today! --&gt;
---

class: inverse, middle

# Variation: univariate analysis

* one continuous variable: **histogram**
* one categorical variable: **bar chart**

We review both plots and focus on code and interpretation.


---

### One continuous variable: **histogram**

TASK: Use the `scorecard` data to show the annual total school attendance cost in the U.S.

For representing one continuous variable (here `cost`): the best graph is usually an histogram

&lt;!-- code this in class, without asking students to help,  before start typing: go back to previous slide and copy code to load library, etc. --&gt;

---



count: false
 
### One continuous variable: **histogram**
.panel1-histogram-auto[

```r
*ggplot(
* data = scorecard,
* mapping = aes(x = cost)
* )
```
]
 
.panel2-histogram-auto[
&lt;img src="index_files/figure-html/histogram_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
### One continuous variable: **histogram**
.panel1-histogram-auto[

```r
ggplot(
  data = scorecard,
  mapping = aes(x = cost)
  ) +
* geom_histogram()
```
]
 
.panel2-histogram-auto[
&lt;img src="index_files/figure-html/histogram_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-histogram-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-histogram-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-histogram-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



HISTOGRAM: for **continuous variables** (here `cost`). It splits the input variable into n sets of equal width and does a frequency count within each set.

--

*Interpretation: What does this histogram tell us? Picks?* 
*Code: What are some alternative ways to rewrite this code (using what we know) to get the same results?*

&lt;!-- ask students to type it in chat, see  
OTHER WAYS TO CODE --&gt;

---



count: false
 
### Bins in histograms
.panel1-histogram-bins-rotate[

```r
ggplot(
  data = scorecard,
  mapping = aes(x = cost)
) +
* geom_histogram(bins = 50)
```
]
 
.panel2-histogram-bins-rotate[
&lt;img src="index_files/figure-html/histogram-bins_rotate_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
### Bins in histograms
.panel1-histogram-bins-rotate[

```r
ggplot(
  data = scorecard,
  mapping = aes(x = cost)
) +
* geom_histogram(bins = 30)
```
]
 
.panel2-histogram-bins-rotate[
&lt;img src="index_files/figure-html/histogram-bins_rotate_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
### Bins in histograms
.panel1-histogram-bins-rotate[

```r
ggplot(
  data = scorecard,
  mapping = aes(x = cost)
) +
* geom_histogram(bins = 10)
```
]
 
.panel2-histogram-bins-rotate[
&lt;img src="index_files/figure-html/histogram-bins_rotate_03_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-histogram-bins-rotate {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-histogram-bins-rotate {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-histogram-bins-rotate {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



Bins: each bar is a bin and represents one interval or set of data. In these examples, we divided the data into 50, 30 (default), or 10 `bins` or equally sized bars. 

Instead than `bins` you can also use `binwidth`, which changes the width of each bin vs. their number (see [here](https://r-charts.com/distribution/histogram-binwidth-ggplot2/))

---

### One categorical variable: **bar chart**

TASK: Show the total number of schools in the U.S. by school type

For representing one categorical variable (here `type`): the best grap is usally a bar chart.

&lt;!-- code this in class, without asking students to help,  before start typing: go back to previous slide and copy code to load library, etc. --&gt;

---



count: false
 
### One categorical variable: Bar chart
.panel1-barplot-auto[

```r
*ggplot(
* data = scorecard,
* mapping = aes(x = type)
*) 
```
]
 
.panel2-barplot-auto[
&lt;img src="index_files/figure-html/barplot_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
### One categorical variable: Bar chart
.panel1-barplot-auto[

```r
ggplot(
  data = scorecard,
  mapping = aes(x = type)
) +
* geom_bar()
```
]
 
.panel2-barplot-auto[
&lt;img src="index_files/figure-html/barplot_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-barplot-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-barplot-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-barplot-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



BAR CHART: for **categorical variables** (here `type`). It takes each category of the variable (here `"Public"`, `"Private nonprofit"`, `"Private for profit"`) and automatically applies a frequency count to aggregate the data by these categories. 

--

*Like we did for the histogram, let's focus on both interpretation and the code.*

&lt;!-- we have already seen how a code similar to this, the previous one, can be rewritten. So let's focus on something new about code: the default statistics for bar chart and why this matter --&gt; 

---

### Bar chart and its default stats

```
ggplot(
  data = scorecard,
  mapping = aes(x = type)
) +
  geom_bar()  # geom_bar(stat = "count")
```

The default stats for `geom_bar()` is not `identity` but is `count`

Documentation [here](https://ggplot2.tidyverse.org/reference/geom_bar.html).

This means that `geom_bar()` automatically counts the number of occurrences for each category on the x variable. That's why, when using `stat = "count"`, you do not need to provide a y variable: `geom_bar()` calculates the counts for you.

---

### Bar chart and its default stats

In practice, under the hood `geom_bar()` performs the equivalent of the following:


```r
scorecard %&gt;%
  count(type)
```

```
## # A tibble: 3 × 2
##   type                    n
##   &lt;fct&gt;               &lt;int&gt;
## 1 Public                536
## 2 Private, nonprofit   1110
## 3 Private, for-profit    86
```

--

It does so, unless we explicitly tell `geom_bar()` not to with `geom_bar(stats = "identity")`. In this case, we need to provide a y with the frequency count of that variable (and if we do that with `count()` it will be stored in the `n` column).

---

### Reorder bar chart levels

.panelset[
.panel[.panel-name[Not Ordered]


&lt;img src="index_files/figure-html/not-ordered-1.png" width="80%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Ordered]

&lt;img src="index_files/figure-html/reordered-1.png" width="80%" style="display: block; margin: auto;" /&gt;

]
]

---

### Reorder bar chart levels (base approach)

Reorder the levels of a categorical variable with `dplyr` and `ggplot` combined:


```
# calculate count for variable of interest and save in new dataframe
count_type &lt;- scorecard %&gt;%
  count(type)

# use the new dataframe to create the graph
ggplot(count_type,
       mapping = aes(x = reorder(type, desc(n)), 
                     y = n)) +
       geom_bar(stat = "identity")
```

--

```
# alternative equivalent code
scorecard %&gt;%
  count(type) %&gt;%
  ggplot(mapping = aes(x = reorder(type, desc(n)), 
                       y = n)) +
  geom_bar(stat = "identity")
```


---

### Reorder bar chart levels (other approaches)

[`fct_relevel()`](https://forcats.tidyverse.org/reference/fct_relevel.html): allows to reorder factor levels by hand

```
scorecard %&gt;%
  mutate(
  type = fct_relevel(.f = type, 
                    levels = "Private, nonprofit", "Public", "Private, for-profit" )) %&gt;%
  ggplot(
    mapping = aes(x = type)) +
    geom_bar()
```

[`fct_infreq()`](https://forcats.tidyverse.org/reference/fct_inorder.html): reorders factor levels by the number of obs. with each level (frequency)

```
scorecard %&gt;%
  mutate(type = fct_infreq(type)) %&gt;%
  ggplot(
    mapping = aes(x = type)) +
  geom_bar()
```

---

### Other types of univariate and bivariate graphs

We examined histograms and bar charts, which are the most common, but there are other options you can experiment with.

See the Visualization cheat sheet: 

* Help &gt; Cheat Sheets &gt; Data Visualization with ggplot2

* Note there are several **cheat sheets** for tidyverse and R: https://posit.co/resources/cheatsheets/

---

class: inverse, middle

# Covariation: bivariate analysis

* two continuous variables: 
  * **scatter plot**
* two categorical variables: 
  * **bar plot** 
  * others: pie chart, dot plot, mosaic plot
* one categorical and one continuous variables: 
  * **box plot**
  * **scatter plot with colors** (one color for each category of the categorical variables)
  * **faceted histogram** (one histogram for each category of the categorical variable)

---

### Two continuous variables: **scatter plot**

TASK: Show the annual total cost and net cost of attendance to schools in the U.S. 

For representing two continuous variables (here `cost` and `netcost`): the best graph is usually a scatter plot

&lt;!-- code this in class, without asking students to help,  before start typing: go back to previous slide and copy code to load library, etc. --&gt;

---



count: false
 
## Scatter plot
.panel1-scatterplot-auto[

```r
*ggplot(
* data = scorecard,
* mapping = aes(
*   x = cost,
*   y = netcost
* )
*) 
```
]
 
.panel2-scatterplot-auto[
&lt;img src="index_files/figure-html/scatterplot_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Scatter plot
.panel1-scatterplot-auto[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = cost,
    y = netcost
  )
) +
* geom_point()
```
]
 
.panel2-scatterplot-auto[
&lt;img src="index_files/figure-html/scatterplot_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-scatterplot-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-scatterplot-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-scatterplot-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



SCATTERPLOT: looks at the relationship between two **continuous variables** (here `cost` and `netcost`). 

--

*What does this scatterplot tell us?*

&lt;!--

As the advertised price increases, the net cost also increases though with significant variations. Some schools have a much lower net cost than their advertised price.

No clear alignment on diagonal, net costs tend to be lower than advertised costs for several schools, especially as the adv costs increase; in most universities the average student pay less than the adv costs. Notice this is a 2d plot bcs we are mapping two variables: one on the y and one on the x.

Link to next slide: for histogram does not make sense to map a second variable on the y, beside count/frequency bcs with a histogram see the total distribution (vs box plot in which you see summary stats of the distribution). 
--&gt;

---

###  Two categorical variables: **bar plot** 

TASK: Show the total number of schools in the U.S. by school type (n = 3) and by state (n = 54)

For representing two categorical variables (here `type` and `state` ) the most appropriate graph is usually a stacked bar chart

&lt;!-- code this in class, without asking students to help,  before start typing: go back to previous slide and copy code to load library, etc. 

why not y? it is a bar chart (y is the frequency count of categories of x) --&gt;

---



count: false
 
### Stacked Bar chart
.panel1-barplot_cat-auto[

```r
*ggplot(
* data = scorecard,
* mapping = aes(
*   x = type,
*   fill = state,
* )
*) 
```
]
 
.panel2-barplot_cat-auto[
&lt;img src="index_files/figure-html/barplot_cat_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
### Stacked Bar chart
.panel1-barplot_cat-auto[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = type,
    fill = state,
  )
) +
* geom_bar(position = "stack")
```
]
 
.panel2-barplot_cat-auto[
&lt;img src="index_files/figure-html/barplot_cat_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
### Stacked Bar chart
.panel1-barplot_cat-auto[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = type,
    fill = state,
  )
) +
  geom_bar(position = "stack") +
* labs(
*   title = "Number of Schools by State and Type",
*   x = "School Type",
*   y = "Count",
*   fill = "State"
* )
```
]
 
.panel2-barplot_cat-auto[
&lt;img src="index_files/figure-html/barplot_cat_auto_03_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-barplot_cat-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-barplot_cat-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-barplot_cat-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



---


STACKED BAR CHART: Each bar represents one category of a categorical variable, and is divided into segments representing the categories of the other categorical variable.

Is this a good graph? Why yes/no? How can we improve it?

&lt;!--
---



This is better, but we are not quite there yet. We need to use `dplyr` first to manipulate the data before visualizing it with `ggplot2`... we come back to this example next lecture when we talk more about `dplyr`!
--&gt;

&lt;!--
For example: aggregate the 54 states using some criteria and then display them...


```r
# count of observations by state
scorecard %&gt;%
  count(state)
```

```
## # A tibble: 54 × 2
##    state     n
##    &lt;chr&gt; &lt;int&gt;
##  1 AK        4
##  2 AL       25
##  3 AR       17
##  4 AZ       16
##  5 CA      118
##  6 CO       21
##  7 CT       24
##  8 DC        7
##  9 DE        4
## 10 FL       57
## # ℹ 44 more rows
```

```r
# define categories using mutate() and case_when()
scorecard &lt;- 
  scorecard %&gt;%
  mutate(region = case_when(
    state %in% c("CT", "ME", "MA", "NH", "RI", "VT", "NJ", "NY", "PA") ~ "Northeast",
    state %in% c("IL", "IN", "IA", "KS", "MI", "MN", "MO", "NE", "ND", "OH", "SD", "WI") ~ "Midwest",
    state %in% c("AL", "AR", "DE", "FL", "GA", "KY", "LA", "MD", "MS", "NC", "OK", "SC", "TN", "TX", "VA", "WV") ~ "South",
    state %in% c("AK", "AZ", "CA", "CO", "HI", "ID", "MT", "NV", "NM", "OR", "UT", "WA", "WY") ~ "West",
    TRUE ~ "Other"
  ))

# check
scorecard %&gt;% count(region, state)
```

```
## # A tibble: 54 × 3
##    region  state     n
##    &lt;chr&gt;   &lt;chr&gt; &lt;int&gt;
##  1 Midwest IA       33
##  2 Midwest IL       62
##  3 Midwest IN       45
##  4 Midwest KS       24
##  5 Midwest MI       45
##  6 Midwest MN       38
##  7 Midwest MO       49
##  8 Midwest ND        9
##  9 Midwest NE       18
## 10 Midwest OH       69
## # ℹ 44 more rows
```

```r
# count(), group_by(), summarize()
by_region &lt;- 
  scorecard %&gt;% 
  count(region, state, type) %&gt;%
  group_by(region, type) %&gt;% 
  summarize(total_by_region = sum(n))

# Create the bar plot
ggplot(by_region, 
       mapping = aes(x = region, 
                     y = total_by_region, 
                     fill = type)) +
  geom_bar(stat = "identity", 
           position = "stack") +
  labs(
    title = "Number of Schools by Region and Type",
    x = "Region",
    y = "Count",
    fill = "School Type"
  )
```

&lt;img src="index_files/figure-html/unnamed-chunk-5-1.png" width="80%" style="display: block; margin: auto;" /&gt;

```r
# NB:
# we need both x and y here because we are using pre-summarized data given by total_by_region and here y represents value directly (counts, sums, etc.); remember to also change stat to identity vs. count
```
--&gt;

---

###  Two categorical variables: **bar plot** 

TASK: Show the total annual cost of attendance by school type (n = 3)

For representing one continuous variable (here `cost`) and a one categorical variable (here `type`), the most appropriate graph is a boxplot

&lt;!-- code this in class, without asking students to help,  before start typing: go back to previous slide and copy code to load library, etc. --&gt;

--- 



count: false
 
## Box plot
.panel1-boxplot-auto[

```r
*ggplot(
* data = scorecard,
* mapping = aes(
*   x = type,
*   y = cost
* )
*) 
```
]
 
.panel2-boxplot-auto[
&lt;img src="index_files/figure-html/boxplot_auto_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Box plot
.panel1-boxplot-auto[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = type,
    y = cost
  )
) +
* geom_boxplot()
```
]
 
.panel2-boxplot-auto[
&lt;img src="index_files/figure-html/boxplot_auto_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-boxplot-auto {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-boxplot-auto {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-boxplot-auto {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



BOX PLOT: looks at the relationship between a **continuous variable** (here `cost`) and a  **categorical variable** (here `type`). It summarizes the continuous variable distribution across each of the categorical variables.

--

What does this box plot tell us?

&lt;!-- median is the line in the middle, the middle value 
Here we see that on average, public universities are the least expensive, followed by private for-profit institutions. I was somewhat surprised by this since for-profit institutions by definition seek to generate a profit, so wouldn't they be the most expensive? But perhaps this makes sense, because they have to attract students so need to offer a better financial value than competing nonprofit or public institutions. Is there a better explanation for these differences? Another question you could explore after viewing this visualization.
--&gt;

---

### Box plot

&lt;img src="https://d33wubrfki0l68.cloudfront.net/153b9af53b33918353fda9b691ded68cd7f62f51/5b616/images/eda-boxplot.png" width="80%" style="display: block; margin: auto;" /&gt;

.footnote[Source of image: R for Data Science Chapter 7]

---



count: false
 
## Multiple windows plot - faceted histogram
.panel1-histogram-facet-user[

```r
*ggplot(
* data = scorecard,
* mapping = aes(x = cost)
*) +
* geom_histogram()
```
]
 
.panel2-histogram-facet-user[
&lt;img src="index_files/figure-html/histogram-facet_user_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Multiple windows plot - faceted histogram
.panel1-histogram-facet-user[

```r
ggplot(
  data = scorecard,
  mapping = aes(x = cost)
) +
  geom_histogram() +
* facet_wrap(facets = vars(type))
```
]
 
.panel2-histogram-facet-user[
&lt;img src="index_files/figure-html/histogram-facet_user_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-histogram-facet-user {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-histogram-facet-user {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-histogram-facet-user {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



HISTOGRAM WITH FACETS: looks at the distribution of a continuous variable (here cost) for several categories (here types of school). 

On the y axis is frequency count for each categorical variable. With histograms we cannot map a second variable, but we can use facets to compare the distribution of each college type. Compare this with box plot.

---



count: false
 
## Multiple windows plot - faceted scatterplot
.panel1-scatterplot-facet-user[

```r
*ggplot(
* data = scorecard,
* mapping = aes(
*   x = cost,
*   y = netcost
* )
*) +
* geom_point()
```
]
 
.panel2-scatterplot-facet-user[
&lt;img src="index_files/figure-html/scatterplot-facet_user_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Multiple windows plot - faceted scatterplot
.panel1-scatterplot-facet-user[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = cost,
    y = netcost
  )
) +
  geom_point() +
* facet_wrap(facets = vars(type))
```
]
 
.panel2-scatterplot-facet-user[
&lt;img src="index_files/figure-html/scatterplot-facet_user_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-scatterplot-facet-user {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel2-scatterplot-facet-user {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
.panel3-scatterplot-facet-user {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 80%
}
&lt;/style&gt;



SCATTERPLOT WITH FACETS: looks at two  **continuous variables** (here cost and netcost) for several categories (here types of school), and plot each in a separate panel with same scale range on the x and y.

---



count: false
 
## Utilizing additional aesthetics
.panel1-scatterplot-mult-channels-rotate[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = cost,
    y = netcost,
*   color = type,
  )
) +
  geom_point()
```
]
 
.panel2-scatterplot-mult-channels-rotate[
&lt;img src="index_files/figure-html/scatterplot-mult-channels_rotate_01_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---
count: false
 
## Utilizing additional aesthetics
.panel1-scatterplot-mult-channels-rotate[

```r
ggplot(
  data = scorecard,
  mapping = aes(
    x = cost,
    y = netcost,
*   color = type, size = debt
  )
) +
  geom_point()
```
]
 
.panel2-scatterplot-mult-channels-rotate[
&lt;img src="index_files/figure-html/scatterplot-mult-channels_rotate_02_output-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

&lt;style&gt;
.panel1-scatterplot-mult-channels-rotate {
  color: black;
  width: 38.6060606060606%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 60%
}
.panel2-scatterplot-mult-channels-rotate {
  color: black;
  width: 59.3939393939394%;
  hight: 32%;
  float: left;
  padding-left: 1%;
  font-size: 60%
}
.panel3-scatterplot-mult-channels-rotate {
  color: black;
  width: NA%;
  hight: 33%;
  float: left;
  padding-left: 1%;
  font-size: 60%
}
&lt;/style&gt;



Rather than using facets (for the school type), we could use the color aesthetic to automatically incorporate the `type` info into the same visualization.

We can also add a fourth variable such as `depth` and render it through the size aesthetic. But does adding `depth` make the graph more informative? 


---

class: inverse, middle

# Factors

---

Categorical variables, also called discrete variables: variables that have a fixed set of possible values. R uses **factors** to work with these variables.

[**Chapter 15 of R for Data Science**](https://r4ds.had.co.nz/factors.html) goes in-depth on creating and modifying factors: 


```r
month_string &lt;- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
month_string
class(month_string)   # character
```


```r
month_factor &lt;- factor(month_string, levels = month_string)
month_factor
class(month_factor)   # factor
```

Notice `class` is the attribute of the object (vs `typeof`: R internal storage of the object)

---

class: inverse, middle

# Practice exploring data

Download today's class material from the website 
---

## Acknowledgments 

The content of these slides is derived in part from Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "magula",
"highlightLines": true,
"highlightLanguage": "r",
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
