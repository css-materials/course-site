---
title: "Functions"
author: "MACSS 30500 <br /> University of Chicago"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      highlightStyle: magula
      highlightLines: true
      highlightLanguage: r
      ratio: 16:9
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
# generate CSS file
library(xaringanthemer)
style_duo_accent(
  primary_color = "#011f4b",
  secondary_color = "#bbd6c7",
  inverse_header_color = "#222222",
  black_color = "#222222",
  header_font_google = xaringanthemer::google_font("Atkinson Hyperlegible"),
  text_font_google = xaringanthemer::google_font("Atkinson Hyperlegible"),
  code_font_google = xaringanthemer::google_font("Source Code Pro"),
  base_font_size = "24px",
  code_font_size = "20px",
  # title_slide_background_image = "https://github.com/uc-dataviz/course-notes/raw/main/images/hexsticker.svg",
  # title_slide_background_size = "contain",
  # title_slide_background_position = "top",
  header_h1_font_size = "2rem",
  header_h2_font_size = "1.75rem",
  header_h3_font_size = "1.5rem",
  extra_css = list(
    "h1" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    "h2" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    "h3" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    ".tiny" = list("font-size" = "70%"),
    ".small" = list("font-size" = "90%"),
    ".midi" = list("font-size" = "150%"),
    ".tiny .remark-code" = list("font-size" = "70%"),
    ".small .remark-code" = list("font-size" = "90%"),
    ".midi .remark-code" = list("font-size" = "150%"),
    ".large" = list("font-size" = "200%"),
    ".xlarge" = list("font-size" = "600%"),
    ".huge" = list(
      "font-size" = "400%",
      "font-family" = "'Montserrat', sans-serif",
      "font-weight" = "bold"
    ),
    ".hand" = list(
      "font-family" = "'Gochi Hand', cursive",
      "font-size" = "125%"
    ),
    ".task" = list(
      "padding-right" = "10px",
      "padding-left" = "10px",
      "padding-top" = "3px",
      "padding-bottom" = "3px",
      "margin-bottom" = "6px",
      "margin-top" = "6px",
      "border-left" = "solid 5px #F1DE67",
      "background-color" = "#F3D03E"
    ),
    ".pull-left" = list(
      "width" = "49%",
      "float" = "left"
    ),
    ".pull-right" = list(
      "width" = "49%",
      "float" = "right"
    ),
    ".pull-left-wide" = list(
      "width" = "70%",
      "float" = "left"
    ),
    ".pull-right-narrow" = list(
      "width" = "27%",
      "float" = "right"
    ),
    ".pull-left-narrow" = list(
      "width" = "27%",
      "float" = "left"
    ),
    ".pull-right-wide" = list(
      "width" = "70%",
      "float" = "right"
    ),
    ".blue" = list(color = "#2A9BB7"),
    ".purple" = list(color = "#a493ba"),
    ".yellow" = list(color = "#f1de67"),
    ".gray" = list(color = "#222222")
  )
)

source(here::here("R", "slide-opts.R"))
```

```{r pkgs, include = FALSE, cache = FALSE}
library(tidyverse)
library(palmerpenguins)
#library(here)
#library(countdown)

set.seed(1234)
theme_set(theme_minimal(base_size = rcis::base_size))
```

class: inverse, middle

## Agenda

* From using to writing functions:
  * Function syntax
  * Things to remember when writing functions
  * Practice
  
* More advanced content:
  * stop()
  * Functions + for loops
  * Arguments
  * Use functions to organize your code
  * Anonymous functions
  * Documenting your function
  * Writing custom functions in the tidyverse

---

class: inverse, middle

# From using to writing functions

---

### Using existing functions

Functions are all over R! We have been **using functions** from day 1 of this class. For example:
```{r}
a <- c(1:10)
a
mean(a)
sqrt(a)
```


---

### Using existing functions
 
Function:
* set of self-contained lines of code that accomplish a specific task
* has a name that is usually descriptive of the task the function performs
* takes an input, processes it, and returns an output

--

Input is made of arguments: 
* they include the object (a data structure like a value, vector, dataframe, etc.) on which the function carries out a task 
* they also include specifications that alter the way the function operates (some of them required, other optional)

---

### Using existing functions

To use a function, we need to know its arguments and pass them correctly. 

In the console, type `help()` with the function's name in parenthesis to learn more about a function behavior and its arguments:
```{r}
help(mean)
help(sqrt)
```

--

Some functions come from base R, like those above. Other functions belong to packages (e.g., all the functions from the tidyverse that we have been using). 

---

### Writing functions

Other than **using** already defined functions, we can **create our own function**! 

When we write a function we need to provide:

* name
* arguments (input), at the very minimum you need to pass a data structure 
* code that manipulates the input, that is what the function does (body)
* return values (output)

Syntax:
```
name <- function(arg1, arg2, ...) { 
    value <- body_of_function
    return(value)
    }
```
<!-- we can assign the func to a named object like any other object and pass one or more argument -->

---

### Writing functions


For example, instead than using the built-in `mean()` function, we could **write our own mean function** to calculate the mean of a vector of numbers.

Syntax:
```
name <- function(arg1, arg2, ...) {  
    value <- body_of_function
    return(value)
    }
```

Our mean function:
``` {r}
my_mean <- function(vector) {
    total_values <- length(vector)
    result <- (sum(vector/total_values))
    return(result)
}
```


---

### Writing functions

Below are two different ways to write the same function: the first is longer because defines two intermediate variables; the second is more compact.

``` {r}
# long version
my_mean <- function(vector) {
  total_values <- length(vector)
  result <- (sum(vector/total_values))
  return(result)
}
```

``` {r}
# short version
my_mean <- function(vector) {
  return(sum(vector/length(vector)))
}
```

---

### Writing functions

To use a function, we need to **call it** with some specific values:
``` {r}
my_mean <- function(vector) {
  return(sum(vector/length(vector)))
}
```

```{r}
a <- c(1:10)
my_mean(vector = a)
b <- c(1, 3, 6, 9, 20, 30)
my_mean(b)
```
--

This function has one argument: `vector`. When we call the function, this argument will take a concrete vector, such as `a`, `b`, etc. We can, but we do not have to, specify the argument name.

---

### Advantages of using functions

Why using a function VS. writing the code without a function?

```{r}
# mean of vector a
a <- c(1:10)
m <- (sum(a/length(a)))
m
```

```{r}
# mean of vector b
b <- c(1, 3, 6, 9, 20, 30)
m <- (sum(b/length(b)))
m
```

<!--
Can do with a loop
```{r}
v <- list(a, b)
output <- vector(mode = "list", length = length(v))

for (i in seq_along(v)) {
  output[[i]] <- (sum(v[[i]]/length(v[[i]])))
  #output[[i]] <- (mean(v[[i]]))
}
output
```
-->

---

### Advantages of using functions

Functions allow to...
* reduce repetitive code and chances for mistakes
* reuse code
* organize code (e.g., one function imports the data, another cleans the data, another splits text into words, etc.)

---

### Quick practice: convert temperature from celsius to fahrenheit

Formula:
```
fahrenheit = (celsius * 9/5) + 32
```

1. open an R script
1. write code to convert 25 degree Celsius to Fahrenheit
  * without a function
  * with a function

---

### Quick practice: convert temperature from celsius to fahrenheit

Write code to convert 25 degree Celsius to Fahrenheit

Without a function:
```
# option 1
fahr <- (25 * 9/5) + 32

# option 2
celsius <- 25
fahr <- (celsius * 9/5) + 32
```

With a function:
```
celsius_to_fahr <- function(celsius) {
  return((celsius * 9/5) + 32)
}
celsius_to_fahr(25)
```

---

### Things to remember when writing functions: name

* use **unique names** (e.g., `my_mean` vs `mean`); if you pick a function name that matches the name of existing R function, your function will override the existing function and only your function will be active in your current session. Type `help()` with your function name in parenthesis to see if the function is already in use 

* use **informative names**: the name should tell you what the function does and should not be too long; do not use reserved words, such as `if`, `else`, `for`, `function`, etc. Type `help(reserved)` in the console to see the full list

* **do not create a new function if one already exists** (e.g., you do not want to create a `my_mean` function since `mean` is already defined in R)


---

### Things to remember when writing functions: variables scope

Variables defined inside a function are NOT available outside it. Their scope lies within and is limited to the function itself:

``` {r}
my_mean <- function(vector) {
    total_values <- length(vector)
    result <- (sum(vector/total_values))
    return(result)
}
```

```{r, error = TRUE}
total_values
```

```{r, error = TRUE}
result
```

---

### Things to remember when writing functions: return statement

If you do not write a `return` statement, your output will be the last statement in your code:

```{r}
my_mean <- function(vector) {
    total_values <- length(vector)
    result <- sum(vector/total_values)
    result
}

my_mean(c(1:10))
```

--

Remember:
* Write a `return` statement: it makes your code easier to read and more explicit.
* Every piece of code after your `return` statement will be ignored. 

---

### Things to remember when writing functions: conditional returns

`return` statements are useful: conditional returns

```{r}
check_number <- function(x) {
  if (x > 0) {
    return("positive")
    }
  else if (x < 0) {
    return("negative")
    }
  else {
    return("zero")
    }
}
check_number(1)
```

If x > 0, the function returns "positive" without evaluating rest of the body.

---

### Things to remember when writing functions: multiple outputs

`return` statements are useful: return multiple objects and collect them into a list or a vector:

```{r}
my_mean <- function(vector) {
    total_values <- length(vector)
    result <- (sum(vector/total_values))
    return(list(total_values, result))
}
my_mean(1:10)
```

---

class: inverse, middle

# Practice writing functions

Download today's class materials from the website

---

class: inverse, middle

# Functions: additional content

---

### Using `stop()` when writing a function

Define a function `celsius_to_fahr()` that converts temperatures from Celsius to Fahrenheit using the formula `fahrenheit = (celsius * 9/5) + 32`

```{r}
celsius_to_fahr <- function(celsius) {
  fahr <- (celsius * 9/5) + 32
  return(fahr)
}
```

```{r}
celsius_to_fahr(0)
celsius_to_fahr(-20)
```

---

### Using `stop()` when writing a function

For the `celsius_to_fahr()` function to work as intended, the argument must be a numeric value. Otherwise, the conversion between the two temperature scales will not work. 

Solution: use `if-else` to check whether the provided argument is a numeric value, and use the function `stop()` to throw an error if that's not the case:

```{r}
celsius_to_fahr <- function(celsius) {
  if (!is.numeric(celsius)) {
    stop("input must be a number")
  } else {
    fahr <- (celsius * 9/5) + 32
    return(fahr) 
  }
}
```

```{r, error = TRUE}
celsius_to_fahr("zero")
```

---

### Functions and for loops

Consider this simulated data (example taken from Ch. 21 of your book) of 4 columns and 10 observations:
```{r}
simulated_df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

head(simulated_df, n = 3)
```

---

### Functions and for loops

To compute the mean for each column, we learned we can use a **for loop**:
```{r}
output <- vector("double", length(simulated_df))

for (i in seq_along(simulated_df)) {
  output[i] <- mean(simulated_df[[i]])
}

output
```

---

### Functions and for loops

If you are going to compute the mean for each column pretty frequently, and/or on different data frames, you might want to **put your for loop into a function**. This way you can write the code once, and call the function every time you need it.

**Practice:** put the code from the previous slide into a function, call the function `column_mean`

<!--
```{r}
column_mean <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- mean(df[[i]])
  }
  return(output)
}

column_mean(simulated_df)
```
-->

---

### Functions and for loops

What if instead than only computing the mean, we want to include also the median and standard deviation? We **could write a function for each**, replacing  `mean()` with `median()`, `sd()`, etc.

<!--
```{r}
column_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  return(output)
}

column_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  return(output)
}
```
-->

---

### Functions with more than one argument

But this way we copied/pasted the code... and the differences among these codes are hard to spot!

**How can we re-write this code more efficiently?** 

Answer: **set up a function with more than one argument**!

---

### Functions with more than one argument

In this example, the first argument is the dataframe, the second is the operation to perform, which can be another function, like `mean()`, `median()`, `sd()`, etc.

```{r}
column_stats <- function(df, stat) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- stat(df[[i]])
  }
  return(output)
}
```

```{r}
column_stats(simulated_df, median)
column_stats(simulated_df, sd)
```

---

### Functions as a way to organize your code 

Pretty cool right?!

How many things we can stuff inside a function? 

- Ideally, functions should short and do one thing. Good habit: break your code into sequential blocks, and write one function for each action (e.g. one function to import data, one to remove NA, one to rename variables, one to calculate descriptive statistics, etc.)

- You can write functions so that the output from one function is the first argument of the next function: this is called functions composition

---

### Functions as a way to organize your code 

Given this vector:
```{r}
v <- c(1:10, NA, NA)
v
```

I want to perform the following two operations, sequentially: remove NAs and calculate the mean (notice here I am using the functions `is.na` and `mean` inside my own function)

```{r}
vect_remove_NA <- function(vector){
 return(vector[!is.na(vector)])
}
```

```{r}
vect_mean <- function(vector) {
  return(mean(vector))
}
```

---

### Functions as a way to organize your code 

First, I call the first function, `vect_remove_NA()`, on my vector `v`. Then, I save the results, and pass them to the second function, `vect_mean()`:
```{r}
v_no_missing <- vect_remove_NA(v)
v_mean <- vect_mean(v_no_missing)
v_mean
```

I can do the same thing using `%>%` (for more see [here](https://rpubs.com/tjmahr/pipelines_2015)):
```{r}
v %>% 
  vect_remove_NA() %>% 
  vect_mean()
```

---

### Functions as a way to organize your code

You can virtually do anything with functions that you can do with vectors:

- assign them to variables 
- store them in lists
- pass them as arguments to other functions 
- create them inside other functions
- return them as the result of a function

<!--
https://github.com/annakrystalli/UNAM/blob/master/Functions_in_R.Rmd
-->

---

### Anonymous functions 

That is **functions without a name**.

You won't define anonymous functions a lot, but you need to know they exist and recognize their syntax.

For example, anonymous functions can be particularly useful:
* if you just want to use a function once and do not want to name it
* when used in conjunction with other functions, such as those from the `apply()` family (your homework asks to explore `apply` as another alternative to for loops)

---

### Anonymous functions

Imagine we have the following function:
```{r}
f <- function(x) {
  x + 3
}
f(2)
```

--

We can re-write it as an anonymous function. Notice the one-line, absence of name, and `()` to call it:
```{r}
(function(x) { x + 3 }) (2)
```

--

Often anonymous functions are written without the `{}`, like this:
```{r}
(function(x) x + 3)(2)
```

<!--
Here's an unammed function for calculating the mean of a vector `x`. In the following example, the input `x` to the function is each element of the list `l`.
```{r}
l <- list(1:5, 5:7)
lapply(l, FUN = function(x){sum(x)/length(x)})
```

see http://adv-r.had.co.nz/Functional-programming.html#anonymous-functions
-->

---

### Anonymous functions: the `purrr` way

The `purrr` package offers another way to write anonymous functions with the `~.` syntax:

```{r}
# anonymous function with purrr (https://purrr.tidyverse.org/reference/map.html)
purrr::map_dbl(1:2, ~.x + 1)

# anonymous function without purrr
(function(x) x + 1)(1:2)

# without anonymous function syntax
add <- function(x) {
  x + 1
}
add(1:2)
```

---

### Quick practice: anonymous functions

Take the function that converts Celsius to Fahrenheit:
```
celsius_to_fahr <- function(celsius) {
return((celsius * 9/5) + 32)
}
```

Rewrite it as anonymous function and call it with one example:
1. Using the regular anonymous function syntax
2. Using `purrr` syntax

---


### Quick practice: anonymous functions

Take the function that converts Celsius to Fahrenheit:
```
celsius_to_fahr <- function(celsius) {
return((celsius * 9/5) + 32)
}
```
<!--
1. Rewrite it using regular anonymous function syntax
```
(function(x) x * 9/5 + 32) (25)
```

2. Rewrite it using `purrr` syntax
```
purrr::map_dbl(25, ~.x * 9/5 + 32)
```
-->

---

### Codying style: documenting your function

Functions should contain a comment immediately below the function definition line. That comment should include:

* one-sentence description of the function
* a list of the function's arguments, denoted by `Args:` with a description of each (including the data type)
* a description of the return value, denoted by `Returns:` 

Make sure to document your functions in the homework assignments!

---

Example from Google's R Style Guide [here](https://web.stanford.edu/class/cs109l/unrestricted/resources/google-style.html#:~:text=Function%20Documentation,-Functions%20should%20contain&text=These%20comments%20should%20consist%20of,value%2C%20denoted%20by%20Returns%3A%20.):

```
CalculateSampleCovariance <- function(x, y, verbose = TRUE) {
  # Computes the sample covariance between two vectors.
  # Args:
  #   x: One of two vectors whose sample covariance is to be calculated.
  #   y: The other vector. x and y must have the same length, greater than one,
  #      with no missing values.
  #   verbose: If TRUE, prints sample covariance; if not, not. Default is TRUE.
  # Returns:
  #   The sample covariance between x and y.
  n <- length(x)
  if (n <= 1 || n != length(y)) {
    stop("Arguments x and y have invalid lengths: ",
         length(x), " and ", length(y), ".")
  }
  if (TRUE %in% is.na(x) || TRUE %in% is.na(y)) {
    stop(" Arguments x and y must not have missing values.")
  }
  covariance <- var(x, y)
  if (verbose)
    cat("Covariance = ", round(covariance, 4), ".\n", sep = "")
  return(covariance)
}
```

---

### Writing custom functions in the tidyverse

You can write custom functions using the tidyverse functions. For example you might want to write a custom function to plot a graph in ggplot or to perform operations with dplyr.

What you need to know to write custom functions that incorporate tidyverse functions:
* syntax to write a custom function
* how to use some special operators that allows R to evaluate your custom functions correctly: 
   * bang-bang `!!`  with `enquo()` 
   * curly-curly `{{ }}` (this replaced the former)

---

### Writing custom functions in the tidyverse

**Using bang-bang `!!`**

* Chapter ["7 Tidy evaluation"](https://krlmlr.github.io/tidyprog/tidy-evaluation.html): explanation with examples on how and why to use `!!` with `enquo`

* Blog post ["Writing Custom Tidyverse Functions"](https://jonthegeek.com/2018/06/04/writing-custom-tidyverse-functions/): explanation with step-by-step example on how and when to use `!!` with `ensym` and with `enquo`

* Another example (without much explanation) [here](http://zevross.com/blog/2018/09/11/writing-efficient-and-streamlined-r-code-with-help-from-the-new-rlang-package/) 


**Using curly-curly `{{ }}`**

* Blog post ["Curly-Curly, the successor of Bang-Bang"](https://www.r-bloggers.com/2019/06/curly-curly-the-successor-of-bang-bang/)

* Another example (without much explanation) [here](https://agstats.io/post/writing-r-functions/) (under "Functions and Tidy Evaluation")