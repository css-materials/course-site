<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Functions</title>
    <meta charset="utf-8" />
    <meta name="author" content="MACSS 30500   University of Chicago" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Functions
]
.author[
### MACSS 30500 <br /> University of Chicago
]

---






class: inverse, middle

## Agenda

* From using to writing functions:
  * Function syntax
  * Things to remember when writing functions
  * Practice
  
* More advanced content:
  * Functions + for loops
  * Arguments
  * Use functions to organize your code
  * Anonymous functions
  * Documenting your function

---

class: inverse, middle

# From using to writing functions

---

### Using existing functions

Functions are all over R! We have been **using functions** from day 1 of this class. For example:

```r
a &lt;- c(1:10)
a
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
mean(a)
```

```
## [1] 5.5
```

```r
sqrt(a)
```

```
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
```


---

### Using existing functions
 
Function:
* set of self-contained lines of code that accomplish a specific task
* has a name that is usually descriptive of the task the function performs
* takes an input, processes it, and returns an output

--

Input is made of arguments: 
* they include the object (a data structure like a value, vector, dataframe, etc.) on which the function carries out a task 
* they also include specifications that alter the way the function operates (some of them required, other optional)

---

### Using existing functions

To use a function, we need to know its arguments and pass them correctly. 

In the console, type `help()` with the function's name in parenthesis to learn more about a function behavior and its arguments:

```r
help(mean)
help(sqrt)
```

--

Some functions come from base R, like those above. Other functions belong to packages (e.g., all the functions from the tidyverse that we have been using). 

---

### Writing functions

Other than **using** already defined functions, we can **create our own function**! 

When we write a function we need to provide:

* name
* arguments (input), at the very minimum you need to pass a data structure 
* code that manipulates the input, that is what the function does (body)
* return values (output)

Syntax:
```
name &lt;- function(arg1, arg2, ...) { 
    value &lt;- body_of_function
    return(value)
    }
```
&lt;!-- we can assign the func to a named object like any other object and pass one or more argument --&gt;

---

### Writing functions


For example, instead than using the built-in `mean()` function, we could **write our own mean function** to calculate the mean of a vector of numbers.

Syntax:
```
name &lt;- function(arg1, arg2, ...) {  
    value &lt;- body_of_function
    return(value)
    }
```

Our mean function:

```r
my_mean &lt;- function(vector) {
    total_values &lt;- length(vector)
    result &lt;- (sum(vector/total_values))
    return(result)
}
```


---

### Writing functions

Below are two different ways to write the same function: the first is longer because defines two intermediate variables; the second is more compact.


```r
# long version
my_mean &lt;- function(vector) {
  total_values &lt;- length(vector)
  result &lt;- (sum(vector/total_values))
  return(result)
}
```


```r
# short version
my_mean &lt;- function(vector) {
  return(sum(vector/length(vector)))
}
```

---

### Writing functions

To use a function, we need to **call it** with some specific values:

```r
my_mean &lt;- function(vector) {
  return(sum(vector/length(vector)))
}
```


```r
a &lt;- c(1:10)
my_mean(vector = a)
```

```
## [1] 5.5
```

```r
b &lt;- c(1, 3, 6, 9, 20, 30)
my_mean(b)
```

```
## [1] 11.5
```
--

This function has one argument: `vector`. When we call the function, this argument will take a concrete vector, such as `a`, `b`, etc. We can, but we do not have to, specify the argument name.

---

### Advantages of using functions

Why using a function VS. writing the code without a function?


```r
# mean of vector a
a &lt;- c(1:10)
m &lt;- (sum(a/length(a)))
m
```

```
## [1] 5.5
```


```r
# mean of vector b
b &lt;- c(1, 3, 6, 9, 20, 30)
m &lt;- (sum(b/length(b)))
m
```

```
## [1] 11.5
```

&lt;!--
Can do with a loop

```r
v &lt;- list(a, b)
output &lt;- vector(mode = "list", length = length(v))

for (i in seq_along(v)) {
  output[[i]] &lt;- (sum(v[[i]]/length(v[[i]])))
  #output[[i]] &lt;- (mean(v[[i]]))
}
output
```

```
## [[1]]
## [1] 5.5
## 
## [[2]]
## [1] 11.5
```
--&gt;

---

### Advantages of using functions

Functions allow to...
* reduce repetitive code and chances for mistakes
* reuse code
* organize code (e.g., one function imports the data, another cleans the data, another splits text into words, etc.)

---

### Practice: convert temperature from celsius to fahrenheit

Formula:
```
fahrenheit = (celsius * 9/5) + 32
```

1. open an R script
1. write code to convert 25 degree Celsius to Fahrenheit
  * without a function
  * with a function

---

### Things to remember when writing functions: name

* use **unique names** (e.g., `my_mean` vs `mean`); if you pick a function name that matches the name of existing R function, your function will override the existing function and only your function will be active in your current session. Type `help()` with your function name in parenthesis to see if the function is already in use 

* use **informative names**: the name should tell you what the function does and should not be too long; do not use reserved words, such as `if`, `else`, `for`, `function`, etc. Type `help(reserved)` in the console to see the full list

* **do not create a new function if one already exists** (e.g., you do not want to create a `my_mean` function since `mean` is already defined in R)


---

### Things to remember when writing functions: variables scope

Variables defined inside the function are NOT available outside it. Their scope lies within and is limited to the function itself:


```r
my_mean &lt;- function(vector) {
    total_values &lt;- length(vector)
    result &lt;- (sum(vector/total_values))
    return(result)
}
```


```r
total_values
```

```
## Error in eval(expr, envir, enclos): object 'total_values' not found
```


```r
result
```

```
## Error in eval(expr, envir, enclos): object 'result' not found
```

---

### Things to remember when writing functions: return statement

If you do not write a `return` statement, your output will be the last statement in your code:


```r
my_mean &lt;- function(vector) {
    total_values &lt;- length(vector)
    result &lt;- sum(vector/total_values)
    result
}

my_mean(c(1:10))
```

```
## [1] 5.5
```

--

Remember:
* Write a `return` statement: it makes your code easier to read and more explicit.
* Every piece of code after your `return` statement will be ignored. 

---

### Things to remember when writing functions: conditional returns

`return` statements are useful: conditional returns


```r
check_number &lt;- function(x) {
  if (x &gt; 0) {
    return("positive")
    }
  else if (x &lt; 0) {
    return("negative")
    }
  else {
    return("zero")
    }
}
check_number(1)
```

```
## [1] "positive"
```

If x &gt; 0, the function returns "positive" without evaluating rest of the body.

---

### Things to remember when writing functions: multiple outputs

`return` statements are useful: return multiple objects and collect them into a list or a vector:


```r
my_mean &lt;- function(vector) {
    total_values &lt;- length(vector)
    result &lt;- (sum(vector/total_values))
    return(list(total_values, result))
}
my_mean(1:10)
```

```
## [[1]]
## [1] 10
## 
## [[2]]
## [1] 5.5
```

---

class: inverse, middle

# Practice writing functions

Download today's class materials from the website

---

class: inverse, middle

# Functions: additional content

---

### Using `stop()` when writing a function

Define a function `celsius_to_fahr()` that converts temperatures from Celsius to Fahrenheit using the formula `fahrenheit = (celsius * 9/5) + 32`


```r
celsius_to_fahr &lt;- function(celsius) {
  fahr &lt;- (celsius * 9/5) + 32
  return(fahr)
}
```


```r
celsius_to_fahr(0)
```

```
## [1] 32
```

```r
celsius_to_fahr(-20)
```

```
## [1] -4
```

---

### Using `stop()` when writing a function

For the `celsius_to_fahr()` function to work as intended, the argument `temp` must be a numeric value. Otherwise, the conversion between the two temperature scales will not work. 

We can use an `if-else` statement to check whether the argument `temp` is a numeric value, and use the function `stop()` to throw and error if that's not the case:


```r
celsius_to_fahr &lt;- function(celsius) {
  if (!is.numeric(celsius)) {
    stop("input must be a number")
  } else {
    fahr &lt;- (celsius * 9/5) + 32
    return(fahr) 
  }
}
```


```r
celsius_to_fahr("zero")
```

```
## Error in celsius_to_fahr("zero"): temp must be a numeric vector
```

---

### Functions and for loops

Consider this simulated data (example taken from Chapter 21 of your book):

```r
simulated_df &lt;- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

head(simulated_df, n = 5)
```

```
## # A tibble: 5 x 4
##        a      b       c      d
##    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1  0.506 -0.110 -1.45   -1.17 
## 2 -0.575 -0.511  0.575  -2.18 
## 3 -0.547 -0.911 -1.02   -1.34 
## 4 -0.564 -0.837 -0.0151 -0.294
## 5 -0.890  2.42  -0.936  -0.466
```

---

### Functions and for loops

To compute the mean for each column, we learned we could use a **for loop**:

```r
output &lt;- vector("double", length(simulated_df))

for (i in seq_along(simulated_df)) {
  output[[i]] &lt;- mean(simulated_df[[i]])
}

output
```

```
## [1] -0.32976859 -0.09851033 -0.50612789 -0.71983177
```

---

### Functions and for loops

But if you are going to compute the mean for each column pretty frequently, and/or on different data frames, you want to **put your for loop into a function**. 

This way you only write the code once, and call the function every time you need it:

```r
col_mean &lt;- function(df) {
  output &lt;- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] &lt;- mean(df[[i]])
  }
  output
}

col_mean(simulated_df)
```

```
## [1] -0.32976859 -0.09851033 -0.50612789 -0.71983177
```

---

### Functions and for loops

What if instead than only computing the mean, you want to include also the median and standard deviation? You **could write a function for each**, replacing  `mean()` with `median()` and `sd()`, like that:


```r
col_median &lt;- function(df) {
  output &lt;- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] &lt;- median(df[[i]])
  }
  output
}

col_sd &lt;- function(df) {
  output &lt;- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] &lt;- sd(df[[i]])
  }
  output
}
```

--

But this way you copied and pasted the code more than twice... and the differences among these codes are hard to spot! **How can we re-write this code more efficiently?** 

---

### Functions with more than one argument

Answer: we can **set up a function with more than one argument**: the first is the data frame, the second is the name of the operation to perform, which can be another function, like `mean()`, `median()`, `sd()`:


```r
col_summary &lt;- function(df, stat) {
  output &lt;- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] &lt;- stat(df[[i]])
  }
  output
}
```


```r
col_summary(simulated_df, median)
```

```
## [1] -0.5555419 -0.4656169 -0.6053490 -0.9248524
```

```r
col_summary(simulated_df, mean)
```

```
## [1] -0.32976859 -0.09851033 -0.50612789 -0.71983177
```

---

### Functions as a way to organize your code 

Pretty cool right?!

How many things we can stuff inside a function? Ideally, functions should short and do **one thing**:

- it is a good habit to break up your code into sequential logical blocks, and write one function for each action (e.g. one function to import data, one to remove NA, one to rename variables, etc.)

- you can write functions so that the output from one function is the first argument to the next function (this is called functions composition)

---

### Functions as a way to organize your code 

Given this vector:

```r
v &lt;- c(1:10, NA, NA)
v
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10 NA NA
```

I want to perform the following two operations, sequentially: remove NAs and calculate the mean (notice here I am using the functions `is.na` and `mean` inside my own function)


```r
vect_remove_NA &lt;- function(vector){
 return(vector[!is.na(vector)])
}
```


```r
vect_mean &lt;- function(vector) {
  return(mean(vector))
}
```

---

### Functions as a way to organize your code 

First, I call the first function, `vect_remove_NA()`, on my vector `v`. Then, I save the results, and pass them to the second function, `vect_mean()`:

```r
vv &lt;- vect_remove_NA(v)
vv &lt;- vect_mean(vv)
vv
```

```
## [1] 5.5
```

I can do the same thing using `%&gt;%` (for more see [here](https://rpubs.com/tjmahr/pipelines_2015)):

```r
p &lt;- c(1,2,3,NA)
p %&gt;% vect_remove_NA() %&gt;% vect_mean()
```

```
## [1] 2
```

&lt;!--
### Functions as a way to organize your code

**You can do anything with functions that you can do with vectors:**

- assign them to variables 
- store them in lists
- pass them as arguments to other functions 
- create them inside functions
- return them as the result of a function

https://github.com/annakrystalli/UNAM/blob/master/Functions_in_R.Rmd
--&gt;

---

### Anonymous functions 

That is **functions without a name**.

You probably won't define anonymous functions a lot, but you need to know they exist and recognize their syntax.

For example, anonymous functions can be particularly useful:
* if you just want to use a function once and do not want to name it
* when used in conjunction with other functions, such as those from the `apply()` family (your homework asks to explore `apply` as another alternative to for loops)

---

### Anonymous functions

Imagine we have the following function:

```r
f &lt;- function(x) {
  x + 3
}
f(2)
```

```
## [1] 5
```

We can re-write it as an anonymous function. Notice the one-line, absence of name, and `()` to call it:

```r
(function(x) { x + 3 }) (2)
```

```
## [1] 5
```

Most often, anonymous functions are written without the `{}`, like this:

```r
(function(x) x + 3)(2)
```

```
## [1] 5
```

&lt;!--
Here's an unammed function for calculating the mean of a vector `x`. In the following example, the input `x` to the function is each element of the list `l`.

```r
l &lt;- list(1:5, 5:7)
lapply(l, FUN = function(x){sum(x)/length(x)})
```

```
## [[1]]
## [1] 3
## 
## [[2]]
## [1] 6
```

see http://adv-r.had.co.nz/Functional-programming.html#anonymous-functions
--&gt;

---

### Anonymous functions: purrr

The `purrr` package in R (from the tidyverse) offers a different way to write anonymous functions: `~.` syntax. Example:


```r
# most clean code
purrr::map_int(1:2, ~.x + 1L)
```

```
## [1] 2 3
```

```r
# middle-of-the-road code
(function(x) x + 1L)(1:2)
```

```
## [1] 2 3
```

```r
# most cumbersome code
xadd &lt;-function(xadd) {
  xadd + 1L
}
xadd(1:2)
```

```
## [1] 2 3
```

---

### Codying style: documenting your function

Functions should contain a comments section immediately below the function definition line. 

* one-sentence description of the function
* a list of the function's arguments, denoted by `Args:` with a description of each (including the data type)
* a description of the return value, denoted by `Returns:`. 

---

Example from Google's R Style Guide [here](https://web.stanford.edu/class/cs109l/unrestricted/resources/google-style.html#:~:text=Function%20Documentation,-Functions%20should%20contain&amp;text=These%20comments%20should%20consist%20of,value%2C%20denoted%20by%20Returns%3A%20.):

```
CalculateSampleCovariance &lt;- function(x, y, verbose = TRUE) {
  # Computes the sample covariance between two vectors.
  # Args:
  #   x: One of two vectors whose sample covariance is to be calculated.
  #   y: The other vector. x and y must have the same length, greater than one,
  #      with no missing values.
  #   verbose: If TRUE, prints sample covariance; if not, not. Default is TRUE.
  # Returns:
  #   The sample covariance between x and y.
  n &lt;- length(x)
  if (n &lt;= 1 || n != length(y)) {
    stop("Arguments x and y have invalid lengths: ",
         length(x), " and ", length(y), ".")
  }
  if (TRUE %in% is.na(x) || TRUE %in% is.na(y)) {
    stop(" Arguments x and y must not have missing values.")
  }
  covariance &lt;- var(x, y)
  if (verbose)
    cat("Covariance = ", round(covariance, 4), ".\n", sep = "")
  return(covariance)
}
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "magula",
"highlightLines": true,
"highlightLanguage": "r",
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
