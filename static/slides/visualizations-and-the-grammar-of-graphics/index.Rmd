---
title: "Visualization and the Grammar of Graphics"
author: "MACSS 30500 <br /> University of Chicago"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      highlightStyle: magula
      highlightLines: true
      highlightLanguage: r
      ratio: 16:9
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
# generate CSS file
library(xaringanthemer)
style_duo_accent(
  primary_color = "#011f4b",
  secondary_color = "#bbd6c7",
  inverse_header_color = "#222222",
  black_color = "#222222",
  header_font_google = xaringanthemer::google_font("Atkinson Hyperlegible"),
  text_font_google = xaringanthemer::google_font("Atkinson Hyperlegible"),
  code_font_google = xaringanthemer::google_font("Source Code Pro"),
  base_font_size = "24px",
  code_font_size = "20px",
  # title_slide_background_image = "https://github.com/uc-dataviz/course-notes/raw/main/images/hexsticker.svg",
  # title_slide_background_size = "contain",
  # title_slide_background_position = "top",
  header_h1_font_size = "2rem",
  header_h2_font_size = "1.75rem",
  header_h3_font_size = "1.5rem",
  extra_css = list(
    "h1" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    "h2" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    "h3" = list(
      "margin-block-start" = "0.4rem",
      "margin-block-end" = "0.4rem"
    ),
    ".tiny" = list("font-size" = "70%"),
    ".small" = list("font-size" = "90%"),
    ".midi" = list("font-size" = "150%"),
    ".tiny .remark-code" = list("font-size" = "70%"),
    ".small .remark-code" = list("font-size" = "90%"),
    ".midi .remark-code" = list("font-size" = "150%"),
    ".large" = list("font-size" = "200%"),
    ".xlarge" = list("font-size" = "600%"),
    ".huge" = list(
      "font-size" = "400%",
      "font-family" = "'Montserrat', sans-serif",
      "font-weight" = "bold"
    ),
    ".hand" = list(
      "font-family" = "'Gochi Hand', cursive",
      "font-size" = "125%"
    ),
    ".task" = list(
      "padding-right" = "10px",
      "padding-left" = "10px",
      "padding-top" = "3px",
      "padding-bottom" = "3px",
      "margin-bottom" = "6px",
      "margin-top" = "6px",
      "border-left" = "solid 5px #F1DE67",
      "background-color" = "#F3D03E"
    ),
    ".pull-left" = list(
      "width" = "49%",
      "float" = "left"
    ),
    ".pull-right" = list(
      "width" = "49%",
      "float" = "right"
    ),
    ".pull-left-wide" = list(
      "width" = "70%",
      "float" = "left"
    ),
    ".pull-right-narrow" = list(
      "width" = "27%",
      "float" = "right"
    ),
    ".pull-left-narrow" = list(
      "width" = "27%",
      "float" = "left"
    ),
    ".pull-right-wide" = list(
      "width" = "70%",
      "float" = "right"
    ),
    ".blue" = list(color = "#2A9BB7"),
    ".purple" = list(color = "#a493ba"),
    ".yellow" = list(color = "#f1de67"),
    ".gray" = list(color = "#222222")
  )
)

source(here::here("R", "slide-opts.R"))
knitr::opts_chunk$set(echo = FALSE)
```

```{r pkgs, include = FALSE, cache = FALSE}
library(tidyverse)
library(knitr)
library(stringr)
library(broom)
library(datasauRus)
library(gganimate)
library(countdown)
library(colorspace)
library(here)
library(gapminder)
library(scales)

set.seed(1234)
theme_set(theme_gray(base_size = 16))
```

class: inverse, middle

# Why visualize data?

---

class: center, middle

Consider the following 13 datasets:

```{r datasaurus-sum-stats, echo = FALSE, message = FALSE, out.width = "80%"}
datasaurus_dozen %>%
  group_by(dataset) %>%
  summarize(n = n(),
            x_mean = mean(x),
            y_mean = mean(y),
            x_sd = sd(x),
            y_sd = sd(y),
            r2 = cor(x, y)) %>%
  mutate(id = row_number()) %>%
  select(id, everything()) %>%
  select(-dataset) %>%
  kable(col.names = c("ID", "$N$", "$\\bar{X}$", "$\\bar{Y}$",
                      "$\\sigma_{X}$", "$\\sigma_{Y}$", "$R$"))
```

---

class: center, middle

If we estimate linear regression models for each dataset, we obtain virtually identical coefficients, perhaps suggesting the relationships are identical

```{r datasaurus-lm, echo = FALSE, results = "asis", out.width = "80%"}
# estimate linear model
datasaurus_model <- datasaurus_dozen %>%
  group_by(dataset) %>%
  nest() %>%
  mutate(model = map(data, ~ lm(y ~ x, data = .x)),
         results = map(model, tidy)) %>%
  unnest(results)

# plot model estimates
datasaurus_model %>%
  ggplot(aes(fct_rev(term), estimate, color = dataset)) +
  geom_pointrange(aes(ymin = estimate - 1.96 * std.error,
                      ymax = estimate + 1.96 * std.error),
                  position = position_dodge(width = 1)) +
  scale_color_discrete_qualitative(palette = "Dark2") +
  labs(subtitle = "Linear regression models with 95% confidence intervals",
       x = NULL,
       y = "Estimated parameter") +
  coord_flip() +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")
```

---

class: center, middle

But what happens if we draw a picture?

```{r datasaurus-graph, echo = FALSE, warning = FALSE, out.width = "80%"}
ggplot(datasaurus_dozen, aes(x = x, y = y))+
  geom_point() +
  tune::coord_obs_pred() +
  theme_minimal(base_size = 14) +
  transition_states(dataset, 3, 3) + 
  ease_aes('cubic-in-out')
```

---

class: center, middle

These 13 datasets give the same linear regression results, yet they are drastically different!

```{r datasaurus-graph-static, echo = FALSE, out.width = "70%"}
ggplot(datasaurus_dozen, aes(x = x, y = y))+
  facet_wrap(vars(dataset), ncol = 5) +
  geom_point(size = 0.75) +
  tune::coord_obs_pred() +
  theme_minimal(base_size = 10)
```

Take Home Point: a good graph CAN reveal a lot about the data, even more than a table or text

---

class: inverse, middle

# The Grammar of Graphics

---

## Grammar and Grammar of Graphics

> A **Grammar** can be broadly defined as the whole structure of a language, governed by a bunch of rules (syntax and morphology). Ultimately a grammar is what makes communication possible!

--

Applied to R and visualizations...

> A **Grammar of Graphics** is a grammar that makes it possible to create a wide range of graphics!

---

### Grammar of Graphics

* It is **a grammar to create a wide range of graphs**

* Grammar of graphics approach is implemented in **[`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html)**, a widely used graphics library for R

* ggplot2 is part of the **[`tidyverse`](https://www.tidyverse.org/)** a collection of R packages that share the same grammar and data structures. We will learn to use multiple packages from tidyverse in this course

---

class: inverse, middle

# Main components of the Grammar of Graphics

See also: 
* "The Grammar of Graphics" notes in our website (summary of R for Data science Ch. 3) 
* ggplot2 book "Components of the layered grammar" [here](https://ggplot2-book.org/mastery#sec-components)

---

### The layered Grammar of Graphics defines a plot a combination of:

* Layer
  * Data (dataset)
  * Mapping (from variables to aesthetics, x and y, color, size, shape, etc.)
  * Statistical transformation (stat)
  * Geometric object (geom)
  * Position adjustment (position)

* Coordinate system (to map the positions of objects onto the plot)

* Facet (to create subsets of the data)

* Scale (one for each aesthetic mapping used on a plot)

--

**Why a layered grammar?** A plot can have multiple layers (example: scatterplot + smoothed line) which can share some of these features.

--

We first see how we can translate these elements into code, then we talk more about some of them
---

### Grammar of Graphics Code template

Code template (shown in Ch. 3) with seven parameters, the bracketed words, which compose the Grammar of Graphics:

```
ggplot(data = <DATA>) + 
  <GEOM>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>) +
  <COORDINATE> +
  <FACET>
```

--

Note: this template is a starting point, but not the only way this code can be written (more on this in a bit)

--

Ch. 3 shows how to fill this template using the `mpg` cars dataset...

---

### Filling the code template using the mpg data

The `mpg` dataset:
* one of multiple 'sample' datasets available for R (like "iris", "mtcars", "gapminder")
* to use it, first load the `tidiverse` library, then the data, finally explore it

```
library(tidyverse)
```
```{r, echo = TRUE}
data(mpg)
head(mpg)
```

---

### Filling the code template using the mpg data

.pull-left[

```
ggplot(data = <DATA>) + 
  <GEOM>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>) +
  <COORDINATE> +
  <FACET>
```
]

.pull-right[
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity") +
  coord_cartesian() +
  facet_wrap(facets = vars(class), 
             nrow = 1)
```
]

* `displ` is a car’s engine size, in litres
* `hwy` is a car’s fuel efficiency on the highway
* `class` is a categorical var that classifies cars into groups (compact, midsize, and SUV)

<!--
facet_wrap(~ class, nrow = 1) 
-->


---

## 

```{r}
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity"
  ) +
  coord_cartesian() +
  facet_wrap(facets = vars(class), nrow = 1)
```

---

## Layers

A layer is defined by five basic parts (data, mapping, stat, geom, position). Layers are used to create the objects on a plot. Layer typically related to one another and share many common features. 

Multiple layers can be built using the same data. For instance, use `geom_point()` to build a scatterplot and use `geom_smooth()` to overlay it with a regression line:

```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity") + 
  geom_smooth(
     mapping = aes(x = displ, y = hwy),
                   method = "lm", se = FALSE)
```

<!-- 
# same code, simplified
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(method = "lm", se = FALSE)
-->

---

### The five parts that make up a layer:


* **Data:** defines the source of the information to be visualized

* **Mapping:** defines how the variables are transformed to "aesthetics" and applied to the plot (at the minimum one variable is mapped to the x position, the other to the y, but usually you will have color, size, etc. )

* **Position:** used especially with dense data we need to adjust the position of elements on the plot to avoid overlaps. Bar plots frequently stack or dodge the bars to avoid overlap:


---

### The five parts that make up a layer:

* **Statistical transformation (stat):** transforms the data, by summarizing them in some way; a stat is a function that takes in a dataset as the input and returns a dataset as the output. You can specify it explicitly or sometimes the transformation is done implicilty 
--

  * Bar graph example: `geom_bar()`implicilty uses `stat_count()` to transform the raw data (summarize observations among categories) before building the plot

  * Identity stat: Sometimes you don’t need to make a statistical transformation at all. For example, in a scatterplot you use the raw values. In these cases the transformation is an identity transformation: the stat passes in the original dataset and exports the exact same dataset

---

### The five parts that make up a layer:

* **Geometric objects (geoms):** to control the type of plot you create. For example, a point geom produces a scatterplot, a line geom produces a line plot, etc. 

 * Each geom can only display certain aesthetics or visual attributes of the geom. For example, a `geom_point()` has position, color, shape, and size aesthetics.

 * How do you know which `aes` a geom takes? consult the documentation!

---

## Coordinate System & Faceting

* **Coordinate System:** to map the position of objects onto the plot plane, the most common is cartesian 

* **Faceting:** to split the dataset up into subsets, and visualize each of them in the same plot. Code: say which variables to use split up the data, and how they should be arranged

Example:
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity"
  ) +
  coord_cartesian() +
  facet_wrap(facets = vars(class), nrow = 1)

```

---

### Test our understanding 

What do these codes produce? And are they all correct?

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue")
```

---

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```
CORRECT CODE. This will map the colors of the points to the class variable of the `mpg` dataset to produce a graph with different colors for each class of car.


```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```
CORRECT CODE. This will produce a graph with all blue points. Here, the color doesn’t convey info about a variable: we are manually setting a color of our choice for the plot, we are not mapping color to a variable. Notice  `color` is outside the `aes()`, thus is not part of the mapping, but is an argument of the `geom_point()` function.

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue")
```
WRONG CODE. This will produce a graph with default colors. This is wrong because we are using color as a mapping aes but we are setting it to the name of a color "blue" VS. a variable.

---

### How to simplify our code template? using defaults

Example from previous slide 

Long code:
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity") + 
  geom_smooth(
     mapping = aes(x = displ, y = hwy),
                   method = "lm", se = FALSE)
```

Short code:
```
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(method = "lm", se = FALSE)
```

---

### How to simplify our code template? using defaults

Another example: scatterplot of cars'engine size (`displ`) and fuel efficiency on the highway (`hwy`)

Long code:
```
ggplot() +
  layer(
    data = mpg, 
    mapping = aes(x = displ, y = hwy),
    geom = "point", 
    stat = "identity", 
    position = "identity") +
  scale_y_continuous() +
  scale_x_continuous() +
  coord_cartesian()
```

Short code:
```
ggplot(data = mpg, 
       aes(x = displ, y = hwy)) +
  geom_point()

```
---

class: inverse, middle

# Practice: Gapminder

Download the in-class exercises from the website (lecture 2)

---

## Gapminder 

* one of multiple 'sample' datasets available for R (like "iris", "mtcars", "mpg")
* to use it, you can just call `install.packages("gapminder")` and load its
* includes information on life expectancy and population for multiple countries over multiple years

<!--
# Exercise: Gapminder

```{r gapminder-over-time, echo = FALSE, out.width = "80%"}
# generate animation of income vs. life expectancy over time
ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = country)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = country_colors, guide = "none") +
  scale_size(range = c(2, 12),
             breaks = c(1e07, 1e08, 5e08),
             labels = label_comma(scale_cut = cut_short_scale())) +
  scale_x_log10(labels = label_dollar(scale_cut = cut_short_scale())) +
  # Here comes the gganimate specific bits
  labs(title = "Quality of life over time",
       subtitle = 'Year: {frame_time}',
       x = 'GDP per capita',
       y = 'Life expectancy',
       size = "Population",
       caption = "Source: Gapminder") +
  theme_xaringan(
    text_font_size = 16,
    title_font_size = 20
  ) +
  theme(
    legend.position = "bottom"
  ) +
  # animation components
  transition_time(year) +
  ease_aes('linear') +
  shadow_wake(wake_length = 0.1) +

# restore defaults
theme_xaringan_restore_defaults()
```
-->
---

# Acknowledgments 

The content of these slides is derived in part from Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.

