<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Visualization and the Grammar of Graphics</title>
    <meta charset="utf-8" />
    <meta name="author" content="MACSS 30500   University of Chicago" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Visualization and the Grammar of Graphics
]
.author[
### MACSS 30500 <br /> University of Chicago
]

---






class: inverse, middle

# Why visualize data?

---

class: center, middle

Consider the following 13 datasets:


| ID| `\(N\)`| `\(\bar{X}\)`| `\(\bar{Y}\)`| `\(\sigma_{X}\)`| `\(\sigma_{Y}\)`|        `\(R\)`|
|--:|---:|---------:|---------:|------------:|------------:|----------:|
|  1| 142|  54.26610|  47.83472|     16.76983|     26.93974| -0.0641284|
|  2| 142|  54.26873|  47.83082|     16.76924|     26.93573| -0.0685864|
|  3| 142|  54.26732|  47.83772|     16.76001|     26.93004| -0.0683434|
|  4| 142|  54.26327|  47.83225|     16.76514|     26.93540| -0.0644719|
|  5| 142|  54.26030|  47.83983|     16.76774|     26.93019| -0.0603414|
|  6| 142|  54.26144|  47.83025|     16.76590|     26.93988| -0.0617148|
|  7| 142|  54.26881|  47.83545|     16.76670|     26.94000| -0.0685042|
|  8| 142|  54.26785|  47.83590|     16.76676|     26.93610| -0.0689797|
|  9| 142|  54.26588|  47.83150|     16.76885|     26.93861| -0.0686092|
| 10| 142|  54.26734|  47.83955|     16.76896|     26.93027| -0.0629611|
| 11| 142|  54.26993|  47.83699|     16.76996|     26.93768| -0.0694456|
| 12| 142|  54.26692|  47.83160|     16.77000|     26.93790| -0.0665752|
| 13| 142|  54.26015|  47.83972|     16.76996|     26.93000| -0.0655833|

---

class: center, middle

If we estimate linear regression models for each dataset, we obtain virtually identical coefficients, perhaps suggesting the relationships are identical

&lt;img src="index_files/figure-html/datasaurus-lm-1.png" width="80%" style="display: block; margin: auto;" /&gt;

---

class: center, middle

But what happens if we draw a picture?

&lt;img src="index_files/figure-html/datasaurus-graph-1.gif" width="80%" style="display: block; margin: auto;" /&gt;

---

class: center, middle

These 13 datasets give the same linear regression results, yet they are drastically different!

&lt;img src="index_files/figure-html/datasaurus-graph-static-1.png" width="70%" style="display: block; margin: auto;" /&gt;

Point: a good graph CAN reveal a lot about the data, than any table or text

---

class: inverse, middle

# The Grammar of Graphics

---

## Grammar and Grammar of Graphics

&gt; A **Grammar** can be broadly defined as the whole structure of a language, with a bunch of rules (syntax and morphology, plus phonology and semantics). Ultimately a grammar is what makes communication possible!

--

Applied to R and visualizations...

&gt; A **Grammar of Graphics** is a grammar that makes it possible to create a wide range of graphics!

---

### Grammar of Graphics

* It is **a grammar to create a wide range of statistical graphs**

* Grammar of graphics approach is implemented in **[`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html)**, a widely used graphics library for R

* ggplot2 is part of the **[`tidyverse`](https://www.tidyverse.org/)** a collection of R packages that share the same grammar and data structures. We will learn to use multiple packages from tidyverse in this course

---

class: inverse, middle

# Main components of the Grammar of Graphics

See "The Grammar of Graphics" notes in our website to follow along (summary of "R for Data Science" Chapter 3)

---

### The layered Grammar of Graphic defines a plot as a combination of:

* Layer
  * Data (dataset)
  * Mapping (from variables to aesthetics, such as color, size, shape, etc.)
  * Statistical transformation (stat)
  * Geometric object (geom)
  * Position adjustment (position)

* Coordinate system (to map the positions of objects onto the plot)

* Faceting (to create subsets of the data)

* Scale (one for each aesthetic mapping used on a plot)

--

Together the data, mappings, stat, geom, position make a layer!
Why a layered grammar? A plot can have multiple layers (example: scatterplot + smoothed line)

Source: ggplot2 book "Components of the layered grammar" [here](https://ggplot2-book.org/mastery#sec-components)

---

### How do we do this in practice? Code template

Code template (shown in Chapter 3) with seven parameters, the bracketed words, which compose the Grammar of Graphics:

```
ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM&gt;(
     mapping = aes(&lt;MAPPINGS&gt;),
     stat = &lt;STAT&gt;, 
     position = &lt;POSITION&gt;
  ) +
  &lt;COORDINATE&gt; +
  &lt;FACET&gt;
```

Note: this template is a useful starting point, but not the only way this code can be written (more on this in a bit)

--

Chapter 3 shows how to fill this template using the `mpg` dataset (about cars)...

---

### Filling the code template using the mpg data

First, let's look at the `mpg` dataset:
* one of multiple 'sample' datasets available for R (like "iris", "mtcars", "gapminder")
* to use it, first load the `tidiverse` library, then the data, finally explore them

```
library(tidyverse)
```

```r
data(mpg)
head(mpg)
```

```
## # A tibble: 6 x 11
##   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class 
##   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa~
## 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa~
## 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa~
## 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa~
## 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa~
## 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa~
```

---

### Filling the code template using the mpg data

.pull-left[

```
ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM&gt;(
     mapping = aes(&lt;MAPPINGS&gt;),
     stat = &lt;STAT&gt;, 
     position = &lt;POSITION&gt;
  ) +
  &lt;COORDINATE&gt; +
  &lt;FACET&gt;
```
]

.pull-right[
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity"
  ) +
  coord_cartesian() +
  facet_wrap(~ class, nrow = 1) 
```
]

* `displ` is a car’s engine size, in litres
* `hwy` is a car’s fuel efficiency on the highway
* `class` is a categorical variable that classifies cars into groups (compact, midsize, and SUV)

---

## 

&lt;img src="index_files/figure-html/unnamed-chunk-2-1.png" width="80%" style="display: block; margin: auto;" /&gt;

---

## Layers

Layers are used to create the objects on a plot. A layer is defined by five basic parts (data, mapping, stat, geom, position)

Layers are typically related to one another and share many common features. 

In our example: we only have one layer, but multiple layers can be built using the same underlying data. For example, we can use `geom_point()` to build a scatterplot and use `geom_smooth()` to overlay it with a smoothed regression line to summarize the relationship between two variables

```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity"
  ) 
```

---

## Data and Mapping

Data defines the source of the information to be visualized, but is independent from the other elements. So a layered graphic can be built which utilizes different data sources while keeping the other components the same.

Mapping defines how the variables are applied to the plot (at the minimum: one variable is mapped to the x position, the other to the y)

SKIP

---

## Statistical tranformation (stat)

* It transforms the data, by summarizing them in some way
* A stat is a function that takes in a dataset as the input and returns a dataset as the output; a stat can add new variables to the original dataset, or create an entirely new dataset 

Example: in a bar graph you typically are not trying to graph the raw data. Instead, you might summarize the data by graphing the total number of observations within a set of categories -- this is what what the geometry `geom_bar()` does automatically when plotting a bar chart. It first transforms the data with the count stats and then uses the transformed data to build the plot. The default stats for `geom_bar()` is in fact `stat_count()`.

Sometimes you don’t need to make a statistical transformation. For example, in a scatterplot you use the raw values for the and variables to map onto the graph. In these situations, the statistical transformation is an identity transformation: the stat simply passes in the original dataset and exports the exact same dataset.

---

## Geometric objects (geoms)

Geometric objects (geoms) control the type of plot you create. For example, a point geom produces a scatterplot, a line geom produces a line plot, etc. Geoms are classified by their dimensions:

* 0 dimensions - point, text
* 1 dimension - path, line
* 2 dimensions - polygon, interval

Each geom can only display certain aesthetics or visual attributes of the geom. For example, a `geom_point()` has position, color, shape, and size aesthetics.

How do you know which aes a geom takes? documentation, here geom_point()


---

## Faceting

* Faceting can be used to split the data up into subsets of the entire dataset. 
* helps to show whether patterns are the same or different across conditions, and allows the subsets to be visualized on the same plot (known as conditioned or trellis plots). * The faceting specification describes which variables should be used to split up the data, and how they should be arranged.

```
ggplot(data = penguins, mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point() +
  facet_wrap(facets = vars(species))

```

---

### How to simplify our code template using defaults

Goal: scatterplot of cars'engine size (`displ`) and fuel efficiency on the highway (`hwy`)

Long code (using our template)
```
ggplot() +
  layer(
    data = mpg, 
    mapping = aes(x = displ, y = hwy),
    geom = "point", 
    stat = "identity", 
    position = "identity"
  ) +
  scale_y_continuous() +
  scale_x_continuous() +
  coord_cartesian()
```

Short code (equivalent)
```
ggplot(data = mpg, 
       aes(x = displ, y = hwy)) +
  geom_point()

```

---

### Why so?

* We only need to specify one geom and stat, since each geom has a default stat.
* Cartesian coordinate systems are most commonly used, so it is the default.
* Default scales can be added based on the aesthetic and type of variables.
* Continuous values are transformed with a linear scaling.
* Discrete values are mapped to integers.
* Scales for aesthetics such as color, fill, and size can also be intelligently defaulted.


---

# Test our understanding

What do these codes produce? And are they all correct?

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue")
```

---

# Test our understanding

What will these codes produce? And are they all correct?

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```
CORRECT CODE. This will map the colors of the points to the class variable in the mpg data set and will produce a graph with different colors for each class of car.


```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```
CORRECT CODE. This will produce a graph with all blue points. Here, the color doesn’t convey information about a variable, but only changes the appearance of the plot. Here we are manually setting a color of our choice, we are not mapping it to a variable. Notice it goes outside the aes(), thus is not part of the mapping, but is an argument of the geom_point() function. Side note: you’ll need to pick a level that makes sense for that aesthetic

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue")
```
WRONG CODE. This will produce a graph with default colors. This is wrong bcs we are using color as a mapping aes but we are setting it to the name of a color "blue" vs a variable

---

class: inverse, middle

# Practice: Gapminder

Download the in-class exercises from the website (lecture 2)

---

## Gapminder 

* one of multiple 'sample' datasets available for R (like "iris", "mtcars", "mpg")
* to use it, you can just call `install.packages("gapminder")` and load its
* includes information on life expectancy and population for multiple countries over multiple years

&lt;!--
# Exercise: Gapminder

&lt;img src="index_files/figure-html/gapminder-over-time-1.gif" width="80%" style="display: block; margin: auto;" /&gt;
--&gt;
---

# Acknowledgments 

The content of these slides is derived in part from Jean Clipperton and Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "magula",
"highlightLines": true,
"highlightLanguage": "r",
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
