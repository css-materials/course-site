<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Visualization and the Grammar of Graphics</title>
    <meta charset="utf-8" />
    <meta name="author" content="MACSS 30500   University of Chicago" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Visualization and the Grammar of Graphics
]
.author[
### MACSS 30500 <br /> University of Chicago
]

---






class: inverse, middle

# Why visualize data?

---

class: center, middle

Consider the following 13 datasets:


| ID| `\(N\)`| `\(\bar{X}\)`| `\(\bar{Y}\)`| `\(\sigma_{X}\)`| `\(\sigma_{Y}\)`|        `\(R\)`|
|--:|---:|---------:|---------:|------------:|------------:|----------:|
|  1| 142|  54.26610|  47.83472|     16.76983|     26.93974| -0.0641284|
|  2| 142|  54.26873|  47.83082|     16.76924|     26.93573| -0.0685864|
|  3| 142|  54.26732|  47.83772|     16.76001|     26.93004| -0.0683434|
|  4| 142|  54.26327|  47.83225|     16.76514|     26.93540| -0.0644719|
|  5| 142|  54.26030|  47.83983|     16.76774|     26.93019| -0.0603414|
|  6| 142|  54.26144|  47.83025|     16.76590|     26.93988| -0.0617148|
|  7| 142|  54.26881|  47.83545|     16.76670|     26.94000| -0.0685042|
|  8| 142|  54.26785|  47.83590|     16.76676|     26.93610| -0.0689797|
|  9| 142|  54.26588|  47.83150|     16.76885|     26.93861| -0.0686092|
| 10| 142|  54.26734|  47.83955|     16.76896|     26.93027| -0.0629611|
| 11| 142|  54.26993|  47.83699|     16.76996|     26.93768| -0.0694456|
| 12| 142|  54.26692|  47.83160|     16.77000|     26.93790| -0.0665752|
| 13| 142|  54.26015|  47.83972|     16.76996|     26.93000| -0.0655833|

---

class: center, middle

If we estimate linear regression models for each dataset, we obtain virtually identical coefficients, perhaps suggesting the relationships are identical

&lt;img src="index_files/figure-html/datasaurus-lm-1.png" width="80%" style="display: block; margin: auto;" /&gt;

---

class: center, middle

But what happens if we draw a picture?

&lt;img src="index_files/figure-html/datasaurus-graph-1.gif" width="80%" style="display: block; margin: auto;" /&gt;

---

class: center, middle

These 13 datasets give the same linear regression results, yet they are drastically different!

&lt;img src="index_files/figure-html/datasaurus-graph-static-1.png" width="70%" style="display: block; margin: auto;" /&gt;

Take Home Point: a good graph CAN reveal a lot about the data, even more than a table or text

---

class: inverse, middle

# The Grammar of Graphics

---

## Grammar and Grammar of Graphics

&gt; A **Grammar** can be broadly defined as the whole structure of a language, governed by a bunch of rules (syntax and morphology). Ultimately a grammar is what makes communication possible!

--

Applied to R and visualizations...

&gt; A **Grammar of Graphics** is a grammar that makes it possible to create a wide range of graphics!

---

### Grammar of Graphics

* It is **a grammar to create a wide range of graphs**

* Grammar of graphics approach is implemented in **[`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/index.html)**, a widely used graphics library for R

* ggplot2 is part of the **[`tidyverse`](https://www.tidyverse.org/)** a collection of R packages that share the same grammar and data structures. We will learn to use multiple packages from tidyverse in this course

---

class: inverse, middle

# Main components of the Grammar of Graphics

See also: 
* "The Grammar of Graphics" notes in our website (summary of R for Data science Ch. 3) 
* ggplot2 book "Components of the layered grammar" [here](https://ggplot2-book.org/mastery#sec-components)

---

### The layered Grammar of Graphics defines a plot a combination of:

* Layer
  * Data (dataset)
  * Mapping (from variables to aesthetics, x and y, color, size, shape, etc.)
  * Statistical transformation (stat)
  * Geometric object (geom)
  * Position adjustment (position)

* Coordinate system (to map the positions of objects onto the plot)

* Facet (to create subsets of the data)

* Scale (one for each aesthetic mapping used on a plot)

--

**Why a layered grammar?** A plot can have multiple layers (example: scatterplot + smoothed line) which can share some of these features.

--

We first see how we can translate these elements into code, then we talk more about some of them
---

### Grammar of Graphics Code template

Code template (shown in Ch. 3) with seven parameters, the bracketed words, which compose the Grammar of Graphics:

```
ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM&gt;(
     mapping = aes(&lt;MAPPINGS&gt;),
     stat = &lt;STAT&gt;, 
     position = &lt;POSITION&gt;) +
  &lt;COORDINATE&gt; +
  &lt;FACET&gt;
```

--

Note: this template is a starting point, but not the only way this code can be written (more on this in a bit)

--

Ch. 3 shows how to fill this template using the `mpg` cars dataset...

---

### Filling the code template using the mpg data

The `mpg` dataset:
* one of multiple 'sample' datasets available for R (like "iris", "mtcars", "gapminder")
* to use it, first load the `tidiverse` library, then the data, finally explore it

```
library(tidyverse)
```

```r
data(mpg)
head(mpg)
```

```
## # A tibble: 6 x 11
##   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class 
##   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa~
## 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa~
## 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa~
## 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa~
## 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa~
## 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa~
```

---

### Filling the code template using the mpg data

.pull-left[

```
ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM&gt;(
     mapping = aes(&lt;MAPPINGS&gt;),
     stat = &lt;STAT&gt;, 
     position = &lt;POSITION&gt;) +
  &lt;COORDINATE&gt; +
  &lt;FACET&gt;
```
]

.pull-right[
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity") +
  coord_cartesian() +
  facet_wrap(facets = vars(class), 
             nrow = 1)
```
]

* `displ` is a car’s engine size, in litres
* `hwy` is a car’s fuel efficiency on the highway
* `class` is a categorical var that classifies cars into groups (compact, midsize, and SUV)

&lt;!--
facet_wrap(~ class, nrow = 1) 
--&gt;


---

## 

&lt;img src="index_files/figure-html/unnamed-chunk-2-1.png" width="80%" style="display: block; margin: auto;" /&gt;

---

## Layers

A layer is defined by five basic parts (data, mapping, stat, geom, position). Layers are used to create the objects on a plot. Layer typically related to one another and share many common features. 

Multiple layers can be built using the same data. For instance, use `geom_point()` to build a scatterplot and use `geom_smooth()` to overlay it with a regression line:

```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity") + 
  geom_smooth(
     mapping = aes(x = displ, y = hwy),
                   method = "lm", se = FALSE)
```

&lt;!-- 
# same code, simplified
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(method = "lm", se = FALSE)
--&gt;

---

### The five parts that make up a layer:


* **Data:** defines the source of the information to be visualized

* **Mapping:** defines how the variables are transformed to "aesthetics" and applied to the plot (at the minimum one variable is mapped to the x position, the other to the y, but usually you will have color, size, etc. )

* **Position:** used especially with dense data we need to adjust the position of elements on the plot to avoid overlaps. Bar plots frequently stack or dodge the bars to avoid overlap:


---

### The five parts that make up a layer:

* **Statistical transformation (stat):** transforms the data, by summarizing them in some way; a stat is a function that takes in a dataset as the input and returns a dataset as the output. You can specify it explicitly or sometimes the transformation is done implicilty 
--

  * Bar graph example: `geom_bar()`implicilty uses `stat_count()` to transform the raw data (summarize observations among categories) before building the plot

  * Identity stat: Sometimes you don’t need to make a statistical transformation at all. For example, in a scatterplot you use the raw values. In these cases the transformation is an identity transformation: the stat passes in the original dataset and exports the exact same dataset

---

### The five parts that make up a layer:

* **Geometric objects (geoms):** to control the type of plot you create. For example, a point geom produces a scatterplot, a line geom produces a line plot, etc. 

 * Each geom can only display certain aesthetics or visual attributes of the geom. For example, a `geom_point()` has position, color, shape, and size aesthetics.

 * How do you know which `aes` a geom takes? consult the documentation!

---

## Coordinate System &amp; Faceting

* **Coordinate System:** to map the position of objects onto the plot plane, the most common is cartesian 

* **Faceting:** to split the dataset up into subsets, and visualize each of them in the same plot. Code: say which variables to use split up the data, and how they should be arranged

Example:
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity"
  ) +
  coord_cartesian() +
  facet_wrap(facets = vars(class), nrow = 1)

```

---

### Test our understanding 

What do these codes produce? And are they all correct?

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue")
```

---

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```
CORRECT CODE. This will map the colors of the points to the class variable of the `mpg` dataset to produce a graph with different colors for each class of car.


```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```
CORRECT CODE. This will produce a graph with all blue points. Here, the color doesn’t convey info about a variable: we are manually setting a color of our choice for the plot, we are not mapping color to a variable. Notice  `color` is outside the `aes()`, thus is not part of the mapping, but is an argument of the `geom_point()` function.

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue")
```
WRONG CODE. This will produce a graph with default colors. This is wrong because we are using color as a mapping aes but we are setting it to the name of a color "blue" VS. a variable.

---

### How to simplify our code template? using defaults

Example from previous slide 

Long code:
```
ggplot(data = mpg) + 
  geom_point(
     mapping = aes(x = displ, y = hwy, 
                   color = class),
     stat = "identity", 
     position = "identity") + 
  geom_smooth(
     mapping = aes(x = displ, y = hwy),
                   method = "lm", se = FALSE)
```

Short code:
```
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(method = "lm", se = FALSE)
```

---

### How to simplify our code template? using defaults

Another example: scatterplot of cars'engine size (`displ`) and fuel efficiency on the highway (`hwy`)

Long code:
```
ggplot() +
  layer(
    data = mpg, 
    mapping = aes(x = displ, y = hwy),
    geom = "point", 
    stat = "identity", 
    position = "identity") +
  scale_y_continuous() +
  scale_x_continuous() +
  coord_cartesian()
```

Short code:
```
ggplot(data = mpg, 
       aes(x = displ, y = hwy)) +
  geom_point()

```
---

class: inverse, middle

# Practice: Gapminder

Download the in-class exercises from the website

---

## Gapminder 

* one of multiple 'sample' datasets available for R (like "iris", "mtcars", "mpg")
* to use it, you can just call `install.packages("gapminder")` and load its
* includes information on life expectancy and population for multiple countries over multiple years

&lt;!--
# Exercise: Gapminder

&lt;img src="index_files/figure-html/gapminder-over-time-1.gif" width="80%" style="display: block; margin: auto;" /&gt;
--&gt;
---

# Acknowledgments 

The content of these slides is derived in part from Benjamin Soltoff’s “Computing for the Social Sciences” course materials, licensed under the CC BY NC 4.0 Creative Commons License. Any errors or oversights are mine alone.

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "magula",
"highlightLines": true,
"highlightLanguage": "r",
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
